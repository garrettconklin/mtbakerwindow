<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holiday Light Mockup Tool V.2 - Professional</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .mockup-container {
            min-height: 100vh;
            background-color: #111827;
            color: white;
        }
        
        .canvas-container {
            position: relative;
            flex: 1;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            cursor: crosshair;
        }
        
        .controls-panel {
            width: 320px;
            background-color: #1f2937;
            border-left: 1px solid #374151;
            overflow-y: auto;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #374151;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #22c55e;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #22c55e;
            cursor: pointer;
            border: none;
        }
        
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background-color: #22c55e;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #16a34a;
        }
        
        .btn-secondary {
            background-color: #374151;
            color: white;
            border: 1px solid #4b5563;
        }
        
        .btn-secondary:hover {
            background-color: #4b5563;
        }
        
        .btn-danger {
            background-color: #dc2626;
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #b91c1c;
        }
        
        .card {
            background-color: #111827;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .select {
            width: 100%;
            padding: 8px 12px;
            background-color: #374151;
            border: 1px solid #4b5563;
            border-radius: 6px;
            color: white;
        }
        
        .upload-area {
            border: 2px dashed #4b5563;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .upload-area:hover {
            border-color: #22c55e;
            background-color: rgba(34, 197, 94, 0.05);
        }
        
        .status-indicator {
            position: absolute;
            top: 16px;
            left: 16px;
            background-color: #22c55e;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .before-after-toggle {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background-color: #1f2937;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 4px;
        }
        
        .toggle-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: #9ca3af;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .toggle-btn.active {
            background-color: #22c55e;
            color: white;
        }
        
        @media (max-width: 1024px) {
            .controls-panel {
                width: 100%;
                max-height: 300px;
            }
            
            .main-content {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="mockup-container">
        <!-- Header -->
        <header class="bg-gray-800 border-b border-gray-700 p-4">
            <div class="max-w-7xl mx-auto flex items-center justify-between">
                <div>
                    <h1 class="text-2xl font-bold text-green-400">Holiday Light Mockup Tool</h1>
                    <p class="text-gray-300 text-sm">Professional Christmas Light Visualization</p>
                </div>
                <div class="flex items-center gap-2">
                    <button id="newPhotoBtn" class="btn btn-secondary" style="display: none;">
                        <i data-lucide="upload"></i>
                        New Photo
                    </button>
                    <button id="undoBtn" class="btn btn-secondary">
                        <i data-lucide="undo"></i>
                    </button>
                    <button id="redoBtn" class="btn btn-secondary">
                        <i data-lucide="redo"></i>
                    </button>
                    <button id="clearBtn" class="btn btn-danger">
                        Clear All
                    </button>
                    <button id="exportBtn" class="btn btn-primary" disabled>
                        <i data-lucide="download"></i>
                        Export
                    </button>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <div class="flex h-[calc(100vh-80px)] main-content">
            <!-- Canvas Area -->
            <div class="flex-1 bg-gray-950 relative canvas-container">
                <!-- Upload Area (shown when no image) -->
                <div id="uploadArea" class="flex items-center justify-center h-full">
                    <div class="upload-area max-w-md mx-auto" onclick="document.getElementById('fileInput').click()">
                        <i data-lucide="image" class="w-16 h-16 text-gray-400 mx-auto mb-4"></i>
                        <h2 class="text-xl font-semibold text-white mb-2">Upload Your Home Photo</h2>
                        <p class="text-gray-300 text-sm mb-4">
                            Upload a daylight photo of your home to start creating your holiday light mockup. 
                            We'll automatically convert it to evening lighting for the best visualization.
                        </p>
                        <div class="btn btn-primary">
                            <i data-lucide="upload"></i>
                            Choose Photo
                        </div>
                        <input type="file" id="fileInput" accept="image/*" style="display: none;">
                        <div class="mt-4 text-xs text-gray-400">
                            <p>Supported formats: JPG, PNG, WebP</p>
                            <p>Best results with clear, well-lit photos</p>
                        </div>
                    </div>
                </div>

                <!-- Canvas (hidden initially) -->
                <canvas id="canvas" style="display: none;"></canvas>

                <!-- Status Indicator -->
                <div id="statusIndicator" class="status-indicator" style="display: none;">
                    Click to add points • Double-click to finish
                </div>

                <!-- Before/After Toggle -->
                <div id="beforeAfterToggle" class="before-after-toggle" style="display: none;">
                    <button class="toggle-btn" id="beforeBtn">
                        <i data-lucide="sun"></i>
                        Before
                    </button>
                    <button class="toggle-btn active" id="afterBtn">
                        <i data-lucide="moon"></i>
                        After
                    </button>
                </div>
            </div>

            <!-- Controls Panel -->
            <div id="controlsPanel" class="controls-panel p-4" style="display: none;">
                <!-- Instructions -->
                <div class="card">
                    <h3 class="text-white font-semibold mb-3">Instructions</h3>
                    <div class="text-sm text-gray-300 space-y-1">
                        <p><strong>String Lights:</strong></p>
                        <p>• Left click to start/continue line</p>
                        <p>• Double-click to finish</p>
                        <p><strong>Mini Lights:</strong></p>
                        <p>• Hold Shift + drag to trace area</p>
                        <p>• Release to finish area</p>
                    </div>
                </div>

                <!-- String Light Settings -->
                <div class="card">
                    <h3 class="text-white font-semibold mb-3">Customize String Lights</h3>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Light Colors</label>
                        <select id="patternSelect" class="select">
                            <option value="warm-white">Warm White</option>
                            <option value="cool-white">Cool White</option>
                            <option value="multi-color">Multi-Color</option>
                            <option value="candy-cane">Candy Cane</option>
                            <option value="icicle">Icicle</option>
                            <option value="blue">Blue</option>
                            <option value="halloween">Halloween</option>
                            <option value="orange">Orange</option>
                        </select>
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">
                            Bulb Spacing: <span id="spacingValue">16</span>"
                        </label>
                        <input type="range" id="spacingSlider" class="slider" min="6" max="18" value="16">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span>6"</span><span>18"</span>
                        </div>
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">
                            Brightness: <span id="brightnessValue">85</span>%
                        </label>
                        <input type="range" id="brightnessSlider" class="slider" min="20" max="100" value="85">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span>20%</span><span>100%</span>
                        </div>
                    </div>
                </div>

                <!-- Mini Light Settings -->
                <div class="card">
                    <h3 class="text-white font-semibold mb-3">Customize Mini Lights</h3>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Light Colors</label>
                        <select id="miniPatternSelect" class="select">
                            <option value="warm-white">Warm White</option>
                            <option value="cool-white">Cool White</option>
                            <option value="multi-color">Multi-Color</option>
                            <option value="candy-cane">Candy Cane</option>
                            <option value="icicle">Icicle</option>
                            <option value="blue">Blue</option>
                            <option value="halloween">Halloween</option>
                            <option value="orange">Orange</option>
                        </select>
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">
                            Size: <span id="miniSizeValue">1.0</span>px
                        </label>
                        <input type="range" id="miniSizeSlider" class="slider" min="0.5" max="1.5" step="0.1" value="1.0">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span>0.5px</span><span>1.5px</span>
                        </div>
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">
                            Density: <span id="miniDensityValue">40</span>%
                        </label>
                        <input type="range" id="miniDensitySlider" class="slider" min="5" max="80" step="5" value="40">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span>5%</span><span>80%</span>
                        </div>
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">
                            Brightness: <span id="miniBrightnessValue">85</span>%
                        </label>
                        <input type="range" id="miniBrightnessSlider" class="slider" min="20" max="100" value="85">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span>20%</span><span>100%</span>
                        </div>
                    </div>
                </div>

                <!-- Light Runs List -->
                <div id="lightRunsList" class="card" style="display: none;">
                    <h3 class="text-white font-semibold mb-3">String Light Runs (<span id="runsCount">0</span>)</h3>
                    <div id="runsContainer" class="space-y-2 max-h-40 overflow-y-auto"></div>
                </div>

                <!-- Mini Light Areas List -->
                <div id="miniAreasList" class="card" style="display: none;">
                    <h3 class="text-white font-semibold mb-3">Mini Light Areas (<span id="areasCount">0</span>)</h3>
                    <div id="areasContainer" class="space-y-2 max-h-40 overflow-y-auto"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize Lucide icons
        lucide.createIcons();

        // Application State
        let appState = {
            uploadedImage: null,
            lightRuns: [],
            miniLightAreas: [],
            currentRun: [],
            currentMiniTrace: [],
            isDrawing: false,
            isTracingMini: false,
            showBefore: false,
            drawingMode: 'idle',
            cooldownUntil: 0,
            settings: {
                pattern: 'warm-white',
                spacing: 16,
                brightness: 85,
                miniPattern: 'warm-white',
                miniSize: 1.0,
                miniDensity: 40,
                miniBrightness: 85
            },
            history: {
                past: [],
                future: []
            }
        };

        // DOM Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const controlsPanel = document.getElementById('controlsPanel');
        const statusIndicator = document.getElementById('statusIndicator');
        const beforeAfterToggle = document.getElementById('beforeAfterToggle');

        // Image handling
        let loadedImage = null;
        let drawRect = { x: 0, y: 0, w: 0, h: 0 };

        // File upload handler
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    loadImage(event.target.result);
                };
                reader.readAsDataURL(file);
            }
        });

        function loadImage(src) {
            const img = new Image();
            img.onload = () => {
                loadedImage = img;
                appState.uploadedImage = src;
                
                // Show canvas and controls, hide upload area
                uploadArea.style.display = 'none';
                canvas.style.display = 'block';
                controlsPanel.style.display = 'block';
                beforeAfterToggle.style.display = 'flex';
                document.getElementById('exportBtn').disabled = false;
                document.getElementById('newPhotoBtn').style.display = 'block';
                
                resizeCanvas();
                drawCanvas();
            };
            img.src = src;
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            if (loadedImage) {
                const imageAspect = loadedImage.width / loadedImage.height;
                const canvasAspect = canvas.width / canvas.height;
                
                if (imageAspect > canvasAspect) {
                    drawRect.w = canvas.width;
                    drawRect.h = drawRect.w / imageAspect;
                    drawRect.x = 0;
                    drawRect.y = (canvas.height - drawRect.h) / 2;
                } else {
                    drawRect.h = canvas.height;
                    drawRect.w = drawRect.h * imageAspect;
                    drawRect.x = (canvas.width - drawRect.w) / 2;
                    drawRect.y = 0;
                }
            }
        }

        // Light pattern colors - True amber warm white like traditional incandescent bulbs
        const patternColors = {
            'warm-white': ['rgb(255, 180, 80)'],
            'cool-white': ['rgb(240, 248, 255)'],
            'multi-color': ['rgb(200, 40, 40)', 'rgb(40, 150, 60)', 'rgb(40, 100, 200)', 'rgb(255, 180, 40)', 'rgb(255, 120, 40)'],
            'candy-cane': ['rgb(255, 180, 80)', 'rgb(200, 40, 40)'],
            'icicle': ['rgb(240, 248, 255)', 'rgb(40, 120, 220)'],
            'blue': ['rgb(40, 100, 200)'],
            'halloween': ['rgb(255, 120, 40)', 'rgb(120, 40, 200)'],
            'orange': ['rgb(255, 120, 40)']
        };

        function drawCanvas() {
            if (!loadedImage) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the image
            ctx.drawImage(loadedImage, drawRect.x, drawRect.y, drawRect.w, drawRect.h);
            
            if (!appState.showBefore) {
                // Apply professional dusk filter
                applyDuskPro();
                
                // Render mini light areas first (behind string lights)
                appState.miniLightAreas.forEach(area => {
                    if (area.visible) {
                        renderMiniLightArea(area);
                    }
                });
                
                // Render current mini trace
                if (appState.currentMiniTrace.length > 0) {
                    drawMiniTrace();
                }
                
                // Render light runs
                appState.lightRuns.forEach(run => {
                    if (run.visible) {
                        renderLightRun(run);
                    }
                });
                
                // Render current drawing run
                if (appState.currentRun.length > 0) {
                    renderCurrentRun();
                }
            }
        }

        function applyDuskPro() {
            // Professional dusk filter with realistic color grading
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = 'rgba(8, 10, 16, 0.35)';
            ctx.fillRect(drawRect.x, drawRect.y, drawRect.w, drawRect.h);
            ctx.restore();
            
            // Gentle contrast lift
            ctx.save();
            ctx.globalCompositeOperation = 'soft-light';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.fillRect(drawRect.x, drawRect.y, drawRect.w, drawRect.h);
            ctx.restore();
            
            // Subtle sky coolness from the top
            const sky = ctx.createLinearGradient(drawRect.x, drawRect.y, drawRect.x, drawRect.y + drawRect.h);
            sky.addColorStop(0, 'rgba(70, 100, 160, 0.20)');
            sky.addColorStop(0.35, 'rgba(60, 80, 120, 0.04)');
            sky.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.save();
            ctx.globalCompositeOperation = 'soft-light';
            ctx.fillStyle = sky;
            ctx.fillRect(drawRect.x, drawRect.y, drawRect.w, drawRect.h);
            ctx.restore();
            
            // Vignette to center attention
            const vignette = ctx.createRadialGradient(
                drawRect.x + drawRect.w / 2, drawRect.y + drawRect.h * 0.55, Math.min(drawRect.w, drawRect.h) * 0.22,
                drawRect.x + drawRect.w / 2, drawRect.y + drawRect.h * 0.55, Math.max(drawRect.w, drawRect.h) * 0.78
            );
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.40)');
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = vignette;
            ctx.fillRect(drawRect.x, drawRect.y, drawRect.w, drawRect.h);
            ctx.restore();
        }

        function renderLightRun(run) {
            if (run.points.length < 2) return;
            
            const colors = patternColors[run.pattern];
            const spacing = run.spacing;
            const brightness = run.brightness / 100;
            
            // Smooth the path slightly for more natural curves
            const smoothedPoints = smoothPolyline(run.points, 0.1);
            const lightPositions = sampleAlongPath(smoothedPoints, spacing);
            
            // Create offscreen canvas for glow effects
            const glowCanvas = document.createElement('canvas');
            glowCanvas.width = canvas.width;
            glowCanvas.height = canvas.height;
            const glowCtx = glowCanvas.getContext('2d');
            
            lightPositions.forEach((pos, index) => {
                const color = colors[index % colors.length];
                drawRealisticBulb(ctx, pos.x, pos.y, color, brightness);
                drawSoftGlow(glowCtx, pos.x, pos.y, color, brightness);
            });
            
            // Apply blur and composite the glow
            glowCtx.filter = 'blur(3px)';
            glowCtx.globalCompositeOperation = 'source-over';
            glowCtx.drawImage(glowCanvas, 0, 0);
            glowCtx.filter = 'none';
            
            // Add the glow to main canvas
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.8;
            ctx.drawImage(glowCanvas, 0, 0);
            ctx.restore();
        }

        function renderMiniLightArea(area) {
            const colors = patternColors[area.pattern];
            const brightness = area.brightness / 100;
            const density = area.density / 100;
            
            // Generate random points within the polygon
            const points = generatePointsInPolygon(area.points, density);
            
            // Create offscreen canvas for glow effects
            const glowCanvas = document.createElement('canvas');
            glowCanvas.width = canvas.width;
            glowCanvas.height = canvas.height;
            const glowCtx = glowCanvas.getContext('2d');
            
            points.forEach((pos, index) => {
                const color = colors[index % colors.length];
                drawMiniLight(ctx, pos.x, pos.y, color, brightness, area.size);
                drawMiniGlow(glowCtx, pos.x, pos.y, color, brightness, area.size);
            });
            
            // Apply blur and composite the glow
            glowCtx.filter = 'blur(2px)';
            glowCtx.globalCompositeOperation = 'source-over';
            glowCtx.drawImage(glowCanvas, 0, 0);
            glowCtx.filter = 'none';
            
            // Add the glow to main canvas
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.6;
            ctx.drawImage(glowCanvas, 0, 0);
            ctx.restore();
        }

        function renderCurrentRun() {
            if (appState.currentRun.length === 0) return;
            
            const colors = patternColors[appState.settings.pattern];
            const spacing = appState.settings.spacing;
            const brightness = appState.settings.brightness / 100;
            
            if (appState.currentRun.length >= 2) {
                const smoothedPoints = smoothPolyline(appState.currentRun, 0.1);
                const lightPositions = sampleAlongPath(smoothedPoints, spacing);
                lightPositions.forEach((pos, index) => {
                    const color = colors[index % colors.length];
                    drawRealisticBulb(ctx, pos.x, pos.y, color, brightness);
                });
            } else if (appState.currentRun.length === 1) {
                const pos = normalizedToCanvas(appState.currentRun[0]);
                drawRealisticBulb(ctx, pos.x, pos.y, colors[0], brightness);
            }
        }

        function drawMiniTrace() {
            if (appState.currentMiniTrace.length < 3) return;
            
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            
            appState.currentMiniTrace.forEach((point, index) => {
                const canvasPos = normalizedToCanvas(point);
                if (index === 0) {
                    ctx.moveTo(canvasPos.x, canvasPos.y);
                } else {
                    ctx.lineTo(canvasPos.x, canvasPos.y);
                }
            });
            
            ctx.stroke();
            ctx.restore();
        }

        function drawRealisticBulb(ctx, x, y, color, brightness) {
            const bulbWidth = 4;   // C9 bulb width - scaled for distance viewing
            const bulbHeight = 6;  // C9 bulb height - scaled for distance viewing
            
            ctx.save();
            
            // Draw socket first (dark base)
            ctx.fillStyle = 'rgba(20, 20, 20, 0.8)';
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.ellipse(x, y + bulbHeight * 0.3, bulbWidth * 0.4, bulbHeight * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Main bulb body - teardrop/flame shape
            ctx.fillStyle = color;
            ctx.globalAlpha = brightness * 0.85;
            ctx.beginPath();
            // Create teardrop shape using bezier curves
            ctx.moveTo(x, y - bulbHeight * 0.5); // top point
            ctx.bezierCurveTo(
                x + bulbWidth * 0.5, y - bulbHeight * 0.3,  // top right curve
                x + bulbWidth * 0.5, y + bulbHeight * 0.1,  // bottom right curve
                x, y + bulbHeight * 0.4                     // bottom point
            );
            ctx.bezierCurveTo(
                x - bulbWidth * 0.5, y + bulbHeight * 0.1,  // bottom left curve
                x - bulbWidth * 0.5, y - bulbHeight * 0.3,  // top left curve
                x, y - bulbHeight * 0.5                     // back to top
            );
            ctx.fill();
            
            // Add faceted texture effect with subtle highlights
            ctx.globalAlpha = brightness * 0.3;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(x - bulbWidth * 0.2, y - bulbHeight * 0.1, bulbWidth * 0.15, bulbHeight * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(x + bulbWidth * 0.15, y + bulbHeight * 0.05, bulbWidth * 0.1, bulbHeight * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Bright filament core (intense center)
            ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
            ctx.globalAlpha = brightness * 1.2;
            ctx.beginPath();
            ctx.ellipse(x, y, bulbWidth * 0.2, bulbHeight * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Ultra-bright center point
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.globalAlpha = brightness;
            ctx.beginPath();
            ctx.ellipse(x, y, bulbWidth * 0.08, bulbHeight * 0.06, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function drawSoftGlow(ctx, x, y, color, brightness) {
            if (!isFinite(x) || !isFinite(y) || !isFinite(brightness)) return;
            
            const glowSize = 8.4; // 30% smaller than original 12
            
            // Create realistic glow with multiple layers
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
            gradient.addColorStop(0, withAlpha(color, 0.9 * brightness));
            gradient.addColorStop(0.2, withAlpha(color, 0.7 * brightness));
            gradient.addColorStop(0.5, withAlpha(color, 0.3 * brightness));
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, glowSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Add directional light cast (downward glow)
            const downGlow = ctx.createRadialGradient(x, y + 10, 0, x, y + 10, glowSize * 0.9);
            downGlow.addColorStop(0, withAlpha(color, 0.5 * brightness));
            downGlow.addColorStop(0.6, withAlpha(color, 0.2 * brightness));
            downGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = downGlow;
            ctx.beginPath();
            ctx.ellipse(x, y + 6, glowSize * 0.9, glowSize * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function drawMiniLight(ctx, x, y, color, brightness, size) {
            ctx.save();
            
            // Main light body
            ctx.fillStyle = color;
            ctx.globalAlpha = brightness * 0.9;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Bright center
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.globalAlpha = brightness;
            ctx.beginPath();
            ctx.arc(x, y, size * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function drawMiniGlow(ctx, x, y, color, brightness, size) {
            if (!isFinite(x) || !isFinite(y) || !isFinite(brightness) || !isFinite(size)) return;
            
            const glowSize = size * 4;
            
            // Create soft glow
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
            gradient.addColorStop(0, withAlpha(color, 0.6 * brightness));
            gradient.addColorStop(0.4, withAlpha(color, 0.3 * brightness));
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, glowSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function smoothPolyline(points, amount = 0.1) {
            if (points.length < 3) return points.slice();
            
            const smoothed = [];
            for (let i = 0; i < points.length - 1; i++) {
                const current = points[i];
                const next = points[i + 1];
                
                smoothed.push(current);
                
                // Add intermediate point for smoothing
                const midX = (current.x + next.x) / 2;
                const midY = (current.y + next.y) / 2;
                smoothed.push({
                    x: current.x + (midX - current.x) * amount,
                    y: current.y + (midY - current.y) * amount
                });
            }
            smoothed.push(points[points.length - 1]);
            
            return smoothed;
        }

        function sampleAlongPath(points, spacing) {
            if (points.length < 2) return [];
            
            const samples = [];
            let totalDistance = 0;
            const segments = [];
            
            // Calculate segment lengths
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = normalizedToCanvas(points[i]);
                const p2 = normalizedToCanvas(points[i + 1]);
                const dist = distance(p1, p2);
                segments.push(dist);
                totalDistance += dist;
            }
            
            if (totalDistance === 0 || !isFinite(totalDistance)) return [];
            
            let currentDistance = 0;
            let targetDistance = 0; // Start at beginning for consistent spacing
            
            for (let i = 0; i < points.length - 1; i++) {
                const segmentLength = segments[i];
                if (segmentLength === 0 || !isFinite(segmentLength)) continue;
                const p1 = normalizedToCanvas(points[i]);
                const p2 = normalizedToCanvas(points[i + 1]);
                
                while (currentDistance + segmentLength >= targetDistance) {
                    const t = (targetDistance - currentDistance) / segmentLength;
                    if (!isFinite(t)) break;
                    const x = p1.x + (p2.x - p1.x) * t;
                    const y = p1.y + (p2.y - p1.y) * t;
                    
                    if (!isFinite(x) || !isFinite(y)) break;
                    
                    samples.push({ x, y, t: targetDistance / totalDistance });
                    targetDistance += spacing;
                }
                
                currentDistance += segmentLength;
            }
            
            // Always include the last point
            const lastPoint = normalizedToCanvas(points[points.length - 1]);
            if (samples.length === 0 || distance(samples[samples.length - 1], lastPoint) > spacing * 0.3) {
                samples.push({
                    x: lastPoint.x,
                    y: lastPoint.y,
                    t: 1
                });
            }
            
            return samples;
        }

        function generatePointsInPolygon(polygon, density) {
            const points = [];
            const canvasPolygon = polygon.map(p => normalizedToCanvas(p));
            
            // Find bounding box
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            canvasPolygon.forEach(point => {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minY = Math.min(minY, point.y);
                maxY = Math.max(maxY, point.y);
            });
            
            // Calculate the area of the polygon to make density proportional
            const polygonArea = calculatePolygonArea(canvasPolygon);
            
            // Base density: 1 light per 40 square pixels at 100% density (2.5x more dense)
            const baseLightsPerArea = polygonArea / 40;
            const numPoints = Math.floor(density * baseLightsPerArea);
            
            let attempts = 0;
            const maxAttempts = numPoints * 10;
            
            while (points.length < numPoints && attempts < maxAttempts) {
                const x = minX + Math.random() * (maxX - minX);
                const y = minY + Math.random() * (maxY - minY);
                
                if (isPointInPolygon({ x, y }, canvasPolygon)) {
                    points.push({ x, y });
                }
                attempts++;
            }
            
            return points;
        }

        function calculatePolygonArea(polygon) {
            if (polygon.length < 3) return 0;
            
            let area = 0;
            for (let i = 0; i < polygon.length; i++) {
                const j = (i + 1) % polygon.length;
                area += polygon[i].x * polygon[j].y;
                area -= polygon[j].x * polygon[i].y;
            }
            return Math.abs(area) / 2;
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            const { x, y } = point;
            
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            
            return inside;
        }

        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        function withAlpha(color, alpha) {
            const match = color.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (match) {
                return `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${Math.max(0, Math.min(1, alpha))})`;
            }
            return color;
        }

        function normalizedToCanvas(point) {
            return {
                x: drawRect.x + point.x * drawRect.w,
                y: drawRect.y + point.y * drawRect.h
            };
        }

        function canvasToNormalized(x, y) {
            if (x < drawRect.x || y < drawRect.y || x > drawRect.x + drawRect.w || y > drawRect.y + drawRect.h) {
                return null;
            }
            return {
                x: (x - drawRect.x) / drawRect.w,
                y: (y - drawRect.y) / drawRect.h
            };
        }

        // Canvas event handlers
        canvas.addEventListener('click', (e) => {
            if (appState.showBefore || appState.isTracingMini) return;
            
            // Check cooldown to prevent accidental clicks
            if (Date.now() < appState.cooldownUntil) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            const normalizedPoint = canvasToNormalized(x, y);
            if (!normalizedPoint) return;
            
            if (appState.drawingMode === 'idle' && !e.shiftKey) {
                // Regular click starts string light drawing
                appState.currentRun = [normalizedPoint];
                appState.drawingMode = 'drawing-string';
                appState.isDrawing = true;
                statusIndicator.style.display = 'block';
                statusIndicator.textContent = 'Click to continue line • Double-click to finish';
            } else if (appState.isDrawing && !e.shiftKey) {
                // Prevent adding duplicate points
                const lastPoint = appState.currentRun[appState.currentRun.length - 1];
                if (lastPoint && Math.abs(normalizedPoint.x - lastPoint.x) < 0.001 && Math.abs(normalizedPoint.y - lastPoint.y) < 0.001) {
                    return;
                }
                appState.currentRun.push(normalizedPoint);
            }
            
            drawCanvas();
        });

        canvas.addEventListener('dblclick', (e) => {
            if (appState.isDrawing && appState.currentRun.length >= 2) {
                // Finish current run
                const newRun = {
                    id: `run-${Date.now()}`,
                    points: [...appState.currentRun],
                    pattern: appState.settings.pattern,
                    spacing: appState.settings.spacing,
                    brightness: appState.settings.brightness,
                    visible: true
                };
                
                appState.lightRuns.push(newRun);
                appState.currentRun = [];
                appState.drawingMode = 'idle';
                appState.isDrawing = false;
                statusIndicator.style.display = 'none';
                
                updateLightRunsList();
                drawCanvas();
            }
        });

        let isMouseDown = false;
        canvas.addEventListener('mousedown', (e) => {
            if (e.shiftKey && appState.drawingMode === 'idle' && Date.now() >= appState.cooldownUntil) {
                isMouseDown = true;
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                const normalizedPoint = canvasToNormalized(x, y);
                if (normalizedPoint) {
                    appState.currentMiniTrace = [normalizedPoint];
                    appState.drawingMode = 'tracing-mini';
                    appState.isTracingMini = true;
                    statusIndicator.style.display = 'block';
                    statusIndicator.textContent = 'Drag to trace area • Release to finish • Move mouse outside to exit mini light mode';
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (appState.isTracingMini && isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                const normalizedPoint = canvasToNormalized(x, y);
                if (normalizedPoint) {
                    const lastPoint = appState.currentMiniTrace[appState.currentMiniTrace.length - 1];
                    if (!lastPoint || Math.abs(normalizedPoint.x - lastPoint.x) > 0.005 || Math.abs(normalizedPoint.y - lastPoint.y) > 0.005) {
                        appState.currentMiniTrace.push(normalizedPoint);
                        drawCanvas();
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (appState.isTracingMini && appState.currentMiniTrace.length >= 3) {
                // Finish mini light area
                const newArea = {
                    id: `mini-${Date.now()}`,
                    points: [...appState.currentMiniTrace],
                    pattern: appState.settings.miniPattern,
                    size: appState.settings.miniSize,
                    density: appState.settings.miniDensity,
                    brightness: appState.settings.miniBrightness,
                    visible: true
                };
                
                appState.miniLightAreas.push(newArea);
                appState.currentMiniTrace = [];
                appState.drawingMode = 'idle';
                appState.isTracingMini = false;
                isMouseDown = false;
                statusIndicator.style.display = 'none';
                
                // Set cooldown to prevent accidental string light creation
                appState.cooldownUntil = Date.now() + 100;
                
                updateMiniAreasList();
                drawCanvas();
            }
        });

        // Control handlers
        document.getElementById('newPhotoBtn').addEventListener('click', () => {
            if (confirm('Upload a new photo? This will clear all current lights.')) {
                // Reset everything
                appState.lightRuns = [];
                appState.miniLightAreas = [];
                appState.currentRun = [];
                appState.currentMiniTrace = [];
                appState.isDrawing = false;
                appState.isTracingMini = false;
                appState.drawingMode = 'idle';
                statusIndicator.style.display = 'none';
                
                // Show upload area, hide canvas
                uploadArea.style.display = 'flex';
                canvas.style.display = 'none';
                controlsPanel.style.display = 'none';
                beforeAfterToggle.style.display = 'none';
                document.getElementById('exportBtn').disabled = true;
                document.getElementById('newPhotoBtn').style.display = 'none';
                
                updateLightRunsList();
                updateMiniAreasList();
            }
        });

        document.getElementById('patternSelect').addEventListener('change', (e) => {
            appState.settings.pattern = e.target.value;
            drawCanvas();
        });

        document.getElementById('spacingSlider').addEventListener('input', (e) => {
            appState.settings.spacing = parseInt(e.target.value);
            document.getElementById('spacingValue').textContent = e.target.value;
            drawCanvas();
        });

        document.getElementById('brightnessSlider').addEventListener('input', (e) => {
            appState.settings.brightness = parseInt(e.target.value);
            document.getElementById('brightnessValue').textContent = e.target.value;
            drawCanvas();
        });

        document.getElementById('miniPatternSelect').addEventListener('change', (e) => {
            appState.settings.miniPattern = e.target.value;
            drawCanvas();
        });

        document.getElementById('miniSizeSlider').addEventListener('input', (e) => {
            appState.settings.miniSize = parseFloat(e.target.value);
            document.getElementById('miniSizeValue').textContent = e.target.value;
            drawCanvas();
        });

        document.getElementById('miniDensitySlider').addEventListener('input', (e) => {
            appState.settings.miniDensity = parseInt(e.target.value);
            document.getElementById('miniDensityValue').textContent = e.target.value;
            drawCanvas();
        });

        document.getElementById('miniBrightnessSlider').addEventListener('input', (e) => {
            appState.settings.miniBrightness = parseInt(e.target.value);
            document.getElementById('miniBrightnessValue').textContent = e.target.value;
            drawCanvas();
        });

        // Before/After toggle
        document.getElementById('beforeBtn').addEventListener('click', () => {
            appState.showBefore = true;
            document.getElementById('beforeBtn').classList.add('active');
            document.getElementById('afterBtn').classList.remove('active');
            drawCanvas();
        });

        document.getElementById('afterBtn').addEventListener('click', () => {
            appState.showBefore = false;
            document.getElementById('afterBtn').classList.add('active');
            document.getElementById('beforeBtn').classList.remove('active');
            drawCanvas();
        });

        // Clear all
        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all lights?')) {
                appState.lightRuns = [];
                appState.miniLightAreas = [];
                appState.currentRun = [];
                appState.currentMiniTrace = [];
                appState.isDrawing = false;
                appState.isTracingMini = false;
                appState.drawingMode = 'idle';
                statusIndicator.style.display = 'none';
                updateLightRunsList();
                updateMiniAreasList();
                drawCanvas();
            }
        });

        // Export
        document.getElementById('exportBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'holiday-lights-mockup.png';
            link.href = canvas.toDataURL();
            link.click();
        });

        function updateLightRunsList() {
            const container = document.getElementById('runsContainer');
            const listElement = document.getElementById('lightRunsList');
            const countElement = document.getElementById('runsCount');
            
            countElement.textContent = appState.lightRuns.length;
            
            if (appState.lightRuns.length === 0) {
                listElement.style.display = 'none';
                return;
            }
            
            listElement.style.display = 'block';
            container.innerHTML = '';
            
            appState.lightRuns.forEach((run, index) => {
                const runElement = document.createElement('div');
                runElement.className = 'flex items-center justify-between bg-gray-800 p-2 rounded';
                runElement.innerHTML = `
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full" style="background-color: ${patternColors[run.pattern][0]}"></div>
                        <span class="text-sm text-gray-300">Run ${index + 1}</span>
                        <span class="text-xs text-gray-400 bg-gray-700 px-2 py-1 rounded">${getPatternLabel(run.pattern)}</span>
                    </div>
                    <div class="flex items-center gap-1">
                        <button class="btn-secondary p-1" onclick="toggleRunVisibility('${run.id}')">
                            <i data-lucide="${run.visible ? 'eye' : 'eye-off'}"></i>
                        </button>
                        <button class="btn-danger p-1" onclick="deleteRun('${run.id}')">
                            <i data-lucide="trash-2"></i>
                        </button>
                    </div>
                `;
                container.appendChild(runElement);
            });
            
            lucide.createIcons();
        }

        function updateMiniAreasList() {
            const container = document.getElementById('areasContainer');
            const listElement = document.getElementById('miniAreasList');
            const countElement = document.getElementById('areasCount');
            
            countElement.textContent = appState.miniLightAreas.length;
            
            if (appState.miniLightAreas.length === 0) {
                listElement.style.display = 'none';
                return;
            }
            
            listElement.style.display = 'block';
            container.innerHTML = '';
            
            appState.miniLightAreas.forEach((area, index) => {
                const areaElement = document.createElement('div');
                areaElement.className = 'flex items-center justify-between bg-gray-800 p-2 rounded';
                areaElement.innerHTML = `
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full" style="background-color: ${patternColors[area.pattern][0]}"></div>
                        <span class="text-sm text-gray-300">Area ${index + 1}</span>
                        <span class="text-xs text-gray-400 bg-gray-700 px-2 py-1 rounded">${getPatternLabel(area.pattern)}</span>
                    </div>
                    <div class="flex items-center gap-1">
                        <button class="btn-secondary p-1" onclick="toggleAreaVisibility('${area.id}')">
                            <i data-lucide="${area.visible ? 'eye' : 'eye-off'}"></i>
                        </button>
                        <button class="btn-danger p-1" onclick="deleteArea('${area.id}')">
                            <i data-lucide="trash-2"></i>
                        </button>
                    </div>
                `;
                container.appendChild(areaElement);
            });
            
            lucide.createIcons();
        }

        function getPatternLabel(pattern) {
            const labels = {
                'warm-white': 'Warm White',
                'cool-white': 'Cool White',
                'multi-color': 'Multi-Color',
                'candy-cane': 'Candy Cane',
                'icicle': 'Icicle',
                'blue': 'Blue',
                'halloween': 'Halloween',
                'orange': 'Orange'
            };
            return labels[pattern] || pattern;
        }

        // Global functions for button handlers
        window.toggleRunVisibility = (id) => {
            const run = appState.lightRuns.find(r => r.id === id);
            if (run) {
                run.visible = !run.visible;
                updateLightRunsList();
                drawCanvas();
            }
        };

        window.deleteRun = (id) => {
            appState.lightRuns = appState.lightRuns.filter(r => r.id !== id);
            updateLightRunsList();
            drawCanvas();
        };

        window.toggleAreaVisibility = (id) => {
            const area = appState.miniLightAreas.find(a => a.id === id);
            if (area) {
                area.visible = !area.visible;
                updateMiniAreasList();
                drawCanvas();
            }
        };

        window.deleteArea = (id) => {
            appState.miniLightAreas = appState.miniLightAreas.filter(a => a.id !== id);
            updateMiniAreasList();
            drawCanvas();
        };

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (appState.isDrawing) {
                    appState.currentRun = [];
                    appState.isDrawing = false;
                    appState.drawingMode = 'idle';
                    statusIndicator.style.display = 'none';
                    drawCanvas();
                }
                if (appState.isTracingMini) {
                    appState.currentMiniTrace = [];
                    appState.isTracingMini = false;
                    appState.drawingMode = 'idle';
                    isMouseDown = false;
                    statusIndicator.style.display = 'none';
                    drawCanvas();
                }
            }
        });

        // Resize handler
        window.addEventListener('resize', () => {
            if (loadedImage) {
                resizeCanvas();
                drawCanvas();
            }
        });

        // Initialize
        resizeCanvas();
    </script>
</body>
</html>