<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holiday Light Mockup Tool - Mt Baker Windows</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .mockup-container {
            min-height: 100vh;
            background-color: #111827;
            color: white;
        }
        
        .canvas-container {
            position: relative;
            flex: 1;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            cursor: crosshair;
        }
        
        .controls-panel {
            width: 320px;
            background-color: #1f2937;
            border-left: 1px solid #374151;
            overflow-y: auto;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #374151;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #22c55e;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #22c55e;
            cursor: pointer;
            border: none;
        }
        
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background-color: #22c55e;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #16a34a;
        }
        
        .btn-secondary {
            background-color: #374151;
            color: white;
            border: 1px solid #4b5563;
        }
        
        .btn-secondary:hover {
            background-color: #4b5563;
        }
        
        .btn-danger {
            background-color: #dc2626;
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #b91c1c;
        }
        
        .card {
            background-color: #111827;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .select {
            width: 100%;
            padding: 8px 12px;
            background-color: #374151;
            border: 1px solid #4b5563;
            border-radius: 6px;
            color: white;
        }
        
        .upload-area {
            border: 2px dashed #4b5563;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .upload-area:hover {
            border-color: #22c55e;
            background-color: rgba(34, 197, 94, 0.05);
        }
        
        .status-indicator {
            position: absolute;
            top: 16px;
            left: 16px;
            background-color: #22c55e;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .before-after-toggle {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background-color: #1f2937;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 4px;
        }
        
        .toggle-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: #9ca3af;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .toggle-btn.active {
            background-color: #22c55e;
            color: white;
        }
        
        @media (max-width: 1024px) {
            .controls-panel {
                width: 100%;
                max-height: 300px;
            }
            
            .main-content {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="mockup-container">
        <!-- Header -->
        <header class="bg-gray-800 border-b border-gray-700 p-4">
            <div class="max-w-7xl mx-auto flex items-center justify-between">
                <div>
                    <h1 class="text-2xl font-bold text-green-400">Mt Baker Windows - Holiday Light Mockup Tool</h1>
                    <p class="text-gray-300 text-sm">Professional Christmas Light Visualization</p>
                </div>
                <div class="flex items-center gap-2">
                    <button id="undoBtn" class="btn btn-secondary" disabled>
                        <i data-lucide="undo"></i>
                    </button>
                    <button id="redoBtn" class="btn btn-secondary" disabled>
                        <i data-lucide="redo"></i>
                    </button>
                    <button id="clearBtn" class="btn btn-danger">
                        Clear All
                    </button>
                    <button id="exportBtn" class="btn btn-primary" disabled>
                        <i data-lucide="download"></i>
                        Export
                    </button>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <div class="flex h-[calc(100vh-80px)] main-content">
            <!-- Canvas Area -->
            <div class="flex-1 bg-gray-950 relative canvas-container">
                <!-- Upload Area (shown when no image) -->
                <div id="uploadArea" class="flex items-center justify-center h-full">
                    <div class="upload-area max-w-md mx-auto" onclick="document.getElementById('fileInput').click()">
                        <i data-lucide="image" class="w-16 h-16 text-gray-400 mx-auto mb-4"></i>
                        <h2 class="text-xl font-semibold text-white mb-2">Upload Your Home Photo</h2>
                        <p class="text-gray-300 text-sm mb-4">
                            Upload a daylight photo of your home to start creating your holiday light mockup.
                            We'll automatically convert it to evening lighting for the best visualization.
                        </p>
                        <div class="btn btn-primary">
                            <i data-lucide="upload"></i>
                            Choose Photo
                        </div>
                        <input type="file" id="fileInput" accept="image/*" style="display: none;">
                    </div>
                </div>

                <!-- Canvas (hidden initially) -->
                <canvas id="canvas" style="display: none;"></canvas>

                <!-- Status Indicator -->
                <div id="statusIndicator" class="status-indicator" style="display: none;">
                    Click to add points • Double-click to finish
                </div>

                <!-- Before/After Toggle -->
                <div id="beforeAfterToggle" class="before-after-toggle" style="display: none;">
                    <button class="toggle-btn" id="beforeBtn">
                        <i data-lucide="sun"></i>
                        Before
                    </button>
                    <button class="toggle-btn active" id="afterBtn">
                        <i data-lucide="moon"></i>
                        After
                    </button>
                </div>
            </div>

            <!-- Controls Panel -->
            <div id="controlsPanel" class="controls-panel p-4" style="display: none;">
                <!-- Instructions -->
                <div class="card">
                    <h3 class="text-white font-semibold mb-3">Instructions</h3>
                    <div class="text-sm text-gray-300 space-y-1">
                        <p><strong>String Lights:</strong></p>
                        <p>• Left click to start/continue line</p>
                        <p>• Double-click to finish</p>
                        <p><strong>Mini Lights:</strong></p>
                        <p>• Hold Shift + drag to trace area</p>
                        <p>• Release to finish area</p>
                    </div>
                </div>

                <!-- String Light Settings -->
                <div class="card">
                    <h3 class="text-white font-semibold mb-3">String Light Settings</h3>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Light Colors</label>
                        <select id="patternSelect" class="select">
                            <option value="warm-white">Warm White</option>
                            <option value="cool-white">Cool White</option>
                            <option value="multi-color">Multi-Color</option>
                            <option value="candy-cane">Candy Cane</option>
                            <option value="icicle">Icicle</option>
                            <option value="blue">Blue</option>
                            <option value="halloween">Halloween</option>
                            <option value="orange">Orange</option>
                        </select>
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">
                            Bulb Spacing: <span id="spacingValue">16</span>"
                        </label>
                        <input type="range" id="spacingSlider" class="slider" min="6" max="18" value="16">
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">
                            Brightness: <span id="brightnessValue">85</span>%
                        </label>
                        <input type="range" id="brightnessSlider" class="slider" min="20" max="100" value="85">
                    </div>
                </div>

                <!-- Mini Light Settings -->
                <div class="card">
                    <h3 class="text-white font-semibold mb-3">Mini Light Settings</h3>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Light Colors</label>
                        <select id="miniPatternSelect" class="select">
                            <option value="warm-white">Warm White</option>
                            <option value="cool-white">Cool White</option>
                            <option value="multi-color">Multi-Color</option>
                            <option value="candy-cane">Candy Cane</option>
                            <option value="icicle">Icicle</option>
                            <option value="blue">Blue</option>
                            <option value="halloween">Halloween</option>
                            <option value="orange">Orange</option>
                        </select>
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">
                            Size: <span id="miniSizeValue">1.0</span>px
                        </label>
                        <input type="range" id="miniSizeSlider" class="slider" min="0.5" max="1.5" step="0.1" value="1.0">
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">
                            Density: <span id="miniDensityValue">40</span>%
                        </label>
                        <input type="range" id="miniDensitySlider" class="slider" min="5" max="80" step="5" value="40">
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">
                            Brightness: <span id="miniBrightnessValue">85</span>%
                        </label>
                        <input type="range" id="miniBrightnessSlider" class="slider" min="20" max="100" value="85">
                    </div>
                </div>

                <!-- Light Runs List -->
                <div id="lightRunsList" class="card" style="display: none;">
                    <h3 class="text-white font-semibold mb-3">String Light Runs</h3>
                    <div id="runsContainer" class="space-y-2 max-h-40 overflow-y-auto"></div>
                </div>

                <!-- Mini Light Areas List -->
                <div id="miniAreasList" class="card" style="display: none;">
                    <h3 class="text-white font-semibold mb-3">Mini Light Areas</h3>
                    <div id="areasContainer" class="space-y-2 max-h-40 overflow-y-auto"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize Lucide icons
        lucide.createIcons();

        // Application State
        let appState = {
            uploadedImage: null,
            lightRuns: [],
            miniLightAreas: [],
            currentRun: [],
            currentMiniTrace: [],
            isDrawing: false,
            isTracingMini: false,
            showBefore: false,
            settings: {
                pattern: 'warm-white',
                spacing: 16,
                brightness: 85,
                miniPattern: 'warm-white',
                miniSize: 1.0,
                miniDensity: 40,
                miniBrightness: 85
            },
            history: {
                past: [],
                future: []
            }
        };

        // DOM Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const controlsPanel = document.getElementById('controlsPanel');
        const statusIndicator = document.getElementById('statusIndicator');
        const beforeAfterToggle = document.getElementById('beforeAfterToggle');

        // Image handling
        let loadedImage = null;
        let drawRect = { x: 0, y: 0, w: 0, h: 0 };

        // File upload handler
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    loadImage(event.target.result);
                };
                reader.readAsDataURL(file);
            }
        });

        function loadImage(src) {
            const img = new Image();
            img.onload = () => {
                loadedImage = img;
                appState.uploadedImage = src;
                
                // Show canvas and controls, hide upload area
                uploadArea.style.display = 'none';
                canvas.style.display = 'block';
                controlsPanel.style.display = 'block';
                beforeAfterToggle.style.display = 'flex';
                document.getElementById('exportBtn').disabled = false;
                
                resizeCanvas();
                drawCanvas();
            };
            img.src = src;
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            if (loadedImage) {
                const imageAspect = loadedImage.width / loadedImage.height;
                const canvasAspect = canvas.width / canvas.height;
                
                if (imageAspect > canvasAspect) {
                    drawRect.w = canvas.width;
                    drawRect.h = drawRect.w / imageAspect;
                    drawRect.x = 0;
                    drawRect.y = (canvas.height - drawRect.h) / 2;
                } else {
                    drawRect.h = canvas.height;
                    drawRect.w = drawRect.h * imageAspect;
                    drawRect.x = (canvas.width - drawRect.w) / 2;
                    drawRect.y = 0;
                }
            }
        }

        // Light pattern colors
        const patternColors = {
            'warm-white': ['rgb(255, 180, 80)'],
            'cool-white': ['rgb(240, 248, 255)'],
            'multi-color': ['rgb(200, 40, 40)', 'rgb(40, 150, 60)', 'rgb(40, 100, 200)', 'rgb(255, 180, 40)', 'rgb(255, 120, 40)'],
            'candy-cane': ['rgb(255, 180, 80)', 'rgb(200, 40, 40)'],
            'icicle': ['rgb(240, 248, 255)', 'rgb(40, 120, 220)'],
            'blue': ['rgb(40, 100, 200)'],
            'halloween': ['rgb(255, 120, 40)', 'rgb(120, 40, 200)'],
            'orange': ['rgb(255, 120, 40)']
        };

        function drawCanvas() {
            if (!loadedImage) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the image
            ctx.drawImage(loadedImage, drawRect.x, drawRect.y, drawRect.w, drawRect.h);
            
            if (!appState.showBefore) {
                // Apply dusk filter
                applyDuskFilter();
                
                // Render mini light areas first
                appState.miniLightAreas.forEach(area => {
                    if (area.visible) {
                        renderMiniLightArea(area);
                    }
                });
                
                // Render current mini trace
                if (appState.currentMiniTrace.length > 0) {
                    drawMiniTrace();
                }
                
                // Render light runs
                appState.lightRuns.forEach(run => {
                    if (run.visible) {
                        renderLightRun(run);
                    }
                });
                
                // Render current drawing run
                if (appState.currentRun.length > 0) {
                    renderCurrentRun();
                }
            }
        }

        function applyDuskFilter() {
            // Professional dusk filter
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = 'rgba(8, 10, 16, 0.35)';
            ctx.fillRect(drawRect.x, drawRect.y, drawRect.w, drawRect.h);
            ctx.restore();
            
            // Add subtle blue tint to shadows
            ctx.save();
            ctx.globalCompositeOperation = 'soft-light';
            ctx.fillStyle = 'rgba(70, 100, 160, 0.15)';
            ctx.fillRect(drawRect.x, drawRect.y, drawRect.w, drawRect.h);
            ctx.restore();
            
            // Add vignette
            const vignette = ctx.createRadialGradient(
                drawRect.x + drawRect.w / 2, drawRect.y + drawRect.h * 0.55, Math.min(drawRect.w, drawRect.h) * 0.22,
                drawRect.x + drawRect.w / 2, drawRect.y + drawRect.h * 0.55, Math.max(drawRect.w, drawRect.h) * 0.78
            );
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.22)');
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = vignette;
            ctx.fillRect(drawRect.x, drawRect.y, drawRect.w, drawRect.h);
            ctx.restore();
        }

        function renderLightRun(run) {
            if (run.points.length < 2) return;
            
            const colors = patternColors[run.pattern];
            const spacing = run.spacing;
            const brightness = run.brightness / 100;
            
            // Calculate light positions along the path
            const lightPositions = sampleAlongPath(run.points, spacing);
            
            lightPositions.forEach((pos, index) => {
                const color = colors[index % colors.length];
                drawLight(pos.x, pos.y, color, brightness, 'string');
            });
        }

        function renderMiniLightArea(area) {
            const colors = patternColors[area.pattern];
            const brightness = area.brightness / 100;
            const density = area.density / 100;
            
            // Generate random points within the polygon
            const points = generatePointsInPolygon(area.points, density);
            
            points.forEach((pos, index) => {
                const color = colors[index % colors.length];
                drawLight(pos.x, pos.y, color, brightness, 'mini', area.size);
            });
        }

        function renderCurrentRun() {
            if (appState.currentRun.length === 0) return;
            
            const colors = patternColors[appState.settings.pattern];
            const spacing = appState.settings.spacing;
            const brightness = appState.settings.brightness / 100;
            
            if (appState.currentRun.length >= 2) {
                const lightPositions = sampleAlongPath(appState.currentRun, spacing);
                lightPositions.forEach((pos, index) => {
                    const color = colors[index % colors.length];
                    drawLight(pos.x, pos.y, color, brightness, 'string');
                });
            } else if (appState.currentRun.length === 1) {
                // Show single point
                const pos = appState.currentRun[0];
                const canvasPos = normalizedToCanvas(pos);
                drawLight(canvasPos.x, canvasPos.y, colors[0], brightness, 'string');
            }
        }

        function drawMiniTrace() {
            if (appState.currentMiniTrace.length < 3) return;
            
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            
            appState.currentMiniTrace.forEach((point, index) => {
                const canvasPos = normalizedToCanvas(point);
                if (index === 0) {
                    ctx.moveTo(canvasPos.x, canvasPos.y);
                } else {
                    ctx.lineTo(canvasPos.x, canvasPos.y);
                }
            });
            
            ctx.stroke();
            ctx.restore();
        }

        function drawLight(x, y, color, brightness, type, size = 1) {
            const bulbWidth = type === 'mini' ? size : 4;
            const bulbHeight = type === 'mini' ? size : 6;
            const glowSize = type === 'mini' ? size * 4 : 8.4;
            
            // Draw glow
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
            gradient.addColorStop(0, withAlpha(color, 0.9 * brightness));
            gradient.addColorStop(0.2, withAlpha(color, 0.7 * brightness));
            gradient.addColorStop(0.5, withAlpha(color, 0.3 * brightness));
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, glowSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            if (type === 'string') {
                // Draw socket
                ctx.save();
                ctx.fillStyle = 'rgba(20, 20, 20, 0.8)';
                ctx.beginPath();
                ctx.ellipse(x, y + bulbHeight * 0.3, bulbWidth * 0.4, bulbHeight * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // Main bulb body - teardrop shape
                ctx.save();
                ctx.fillStyle = color;
                ctx.globalAlpha = brightness * 0.85;
                ctx.beginPath();
                ctx.moveTo(x, y - bulbHeight * 0.5);
                ctx.bezierCurveTo(
                    x + bulbWidth * 0.5, y - bulbHeight * 0.3,
                    x + bulbWidth * 0.5, y + bulbHeight * 0.1,
                    x, y + bulbHeight * 0.4
                );
                ctx.bezierCurveTo(
                    x - bulbWidth * 0.5, y + bulbHeight * 0.1,
                    x - bulbWidth * 0.5, y - bulbHeight * 0.3,
                    x, y - bulbHeight * 0.5
                );
                ctx.fill();
                ctx.restore();
                
                // Highlights
                ctx.save();
                ctx.globalAlpha = brightness * 0.3;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.ellipse(x - bulbWidth * 0.2, y - bulbHeight * 0.1, bulbWidth * 0.15, bulbHeight * 0.1, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            } else {
                // Mini light
                ctx.save();
                ctx.fillStyle = color;
                ctx.globalAlpha = brightness * 0.9;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Bright center
            ctx.save();
            ctx.fillStyle = type === 'string' ? 'rgba(255, 255, 200, 0.9)' : 'rgba(255, 255, 255, 0.8)';
            ctx.globalAlpha = brightness;
            ctx.beginPath();
            const centerSize = type === 'string' ? bulbWidth * 0.2 : size * 0.4;
            ctx.arc(x, y, centerSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function sampleAlongPath(points, spacing) {
            if (points.length < 2) return [];
            
            const samples = [];
            let totalDistance = 0;
            const segments = [];
            
            // Calculate segment lengths
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = normalizedToCanvas(points[i]);
                const p2 = normalizedToCanvas(points[i + 1]);
                const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                segments.push(dist);
                totalDistance += dist;
            }
            
            if (totalDistance === 0) return [];
            
            let currentDistance = 0;
            let targetDistance = 0;
            
            for (let i = 0; i < points.length - 1; i++) {
                const segmentLength = segments[i];
                const p1 = normalizedToCanvas(points[i]);
                const p2 = normalizedToCanvas(points[i + 1]);
                
                while (currentDistance + segmentLength >= targetDistance) {
                    const t = (targetDistance - currentDistance) / segmentLength;
                    const x = p1.x + (p2.x - p1.x) * t;
                    const y = p1.y + (p2.y - p1.y) * t;
                    
                    samples.push({ x, y });
                    targetDistance += spacing;
                }
                
                currentDistance += segmentLength;
            }
            
            return samples;
        }

        function generatePointsInPolygon(polygon, density) {
            const points = [];
            const canvasPolygon = polygon.map(p => normalizedToCanvas(p));
            
            // Find bounding box
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            canvasPolygon.forEach(point => {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minY = Math.min(minY, point.y);
                maxY = Math.max(maxY, point.y);
            });
            
            const area = (maxX - minX) * (maxY - minY);
            const numPoints = Math.floor(area * density / 40);
            
            let attempts = 0;
            while (points.length < numPoints && attempts < numPoints * 10) {
                const x = minX + Math.random() * (maxX - minX);
                const y = minY + Math.random() * (maxY - minY);
                
                if (isPointInPolygon({ x, y }, canvasPolygon)) {
                    points.push({ x, y });
                }
                attempts++;
            }
            
            return points;
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            const { x, y } = point;
            
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            
            return inside;
        }

        function withAlpha(color, alpha) {
            const match = color.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (match) {
                return `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${alpha})`;
            }
            return color;
        }

        function normalizedToCanvas(point) {
            return {
                x: drawRect.x + point.x * drawRect.w,
                y: drawRect.y + point.y * drawRect.h
            };
        }

        function canvasToNormalized(x, y) {
            if (x < drawRect.x || y < drawRect.y || x > drawRect.x + drawRect.w || y > drawRect.y + drawRect.h) {
                return null;
            }
            return {
                x: (x - drawRect.x) / drawRect.w,
                y: (y - drawRect.y) / drawRect.h
            };
        }

        // Canvas event handlers
        canvas.addEventListener('click', (e) => {
            if (appState.showBefore || appState.isTracingMini) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            const normalizedPoint = canvasToNormalized(x, y);
            if (!normalizedPoint) return;
            
            if (!appState.isDrawing) {
                // Start new run
                appState.currentRun = [normalizedPoint];
                appState.isDrawing = true;
                statusIndicator.style.display = 'block';
                statusIndicator.textContent = 'Click to continue • Double-click to finish';
            } else {
                // Add point to current run
                appState.currentRun.push(normalizedPoint);
            }
            
            drawCanvas();
        });

        canvas.addEventListener('dblclick', (e) => {
            if (appState.isDrawing && appState.currentRun.length >= 2) {
                // Finish current run
                const newRun = {
                    id: Date.now().toString(),
                    points: [...appState.currentRun],
                    pattern: appState.settings.pattern,
                    spacing: appState.settings.spacing,
                    brightness: appState.settings.brightness,
                    visible: true
                };
                
                appState.lightRuns.push(newRun);
                appState.currentRun = [];
                appState.isDrawing = false;
                statusIndicator.style.display = 'none';
                
                updateLightRunsList();
                drawCanvas();
            }
        });

        let isMouseDown = false;
        canvas.addEventListener('mousedown', (e) => {
            if (e.shiftKey && !appState.isDrawing) {
                isMouseDown = true;
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                const normalizedPoint = canvasToNormalized(x, y);
                if (normalizedPoint) {
                    appState.currentMiniTrace = [normalizedPoint];
                    appState.isTracingMini = true;
                    statusIndicator.style.display = 'block';
                    statusIndicator.textContent = 'Drag to trace area • Release to finish';
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (appState.isTracingMini && isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                const normalizedPoint = canvasToNormalized(x, y);
                if (normalizedPoint) {
                    const lastPoint = appState.currentMiniTrace[appState.currentMiniTrace.length - 1];
                    const distance = Math.sqrt((normalizedPoint.x - lastPoint.x) ** 2 + (normalizedPoint.y - lastPoint.y) ** 2);
                    
                    if (distance > 0.01) {
                        appState.currentMiniTrace.push(normalizedPoint);
                        drawCanvas();
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (appState.isTracingMini && appState.currentMiniTrace.length >= 3) {
                // Finish mini light area
                const newArea = {
                    id: Date.now().toString(),
                    points: [...appState.currentMiniTrace],
                    pattern: appState.settings.miniPattern,
                    size: appState.settings.miniSize,
                    density: appState.settings.miniDensity,
                    brightness: appState.settings.miniBrightness,
                    visible: true
                };
                
                appState.miniLightAreas.push(newArea);
                appState.currentMiniTrace = [];
                appState.isTracingMini = false;
                isMouseDown = false;
                statusIndicator.style.display = 'none';
                
                updateMiniAreasList();
                drawCanvas();
            }
        });

        // Control handlers
        document.getElementById('patternSelect').addEventListener('change', (e) => {
            appState.settings.pattern = e.target.value;
            drawCanvas();
        });

        document.getElementById('spacingSlider').addEventListener('input', (e) => {
            appState.settings.spacing = parseInt(e.target.value);
            document.getElementById('spacingValue').textContent = e.target.value;
            drawCanvas();
        });

        document.getElementById('brightnessSlider').addEventListener('input', (e) => {
            appState.settings.brightness = parseInt(e.target.value);
            document.getElementById('brightnessValue').textContent = e.target.value;
            drawCanvas();
        });

        document.getElementById('miniPatternSelect').addEventListener('change', (e) => {
            appState.settings.miniPattern = e.target.value;
            drawCanvas();
        });

        document.getElementById('miniSizeSlider').addEventListener('input', (e) => {
            appState.settings.miniSize = parseFloat(e.target.value);
            document.getElementById('miniSizeValue').textContent = e.target.value;
            drawCanvas();
        });

        document.getElementById('miniDensitySlider').addEventListener('input', (e) => {
            appState.settings.miniDensity = parseInt(e.target.value);
            document.getElementById('miniDensityValue').textContent = e.target.value;
            drawCanvas();
        });

        document.getElementById('miniBrightnessSlider').addEventListener('input', (e) => {
            appState.settings.miniBrightness = parseInt(e.target.value);
            document.getElementById('miniBrightnessValue').textContent = e.target.value;
            drawCanvas();
        });

        // Before/After toggle
        document.getElementById('beforeBtn').addEventListener('click', () => {
            appState.showBefore = true;
            document.getElementById('beforeBtn').classList.add('active');
            document.getElementById('afterBtn').classList.remove('active');
            drawCanvas();
        });

        document.getElementById('afterBtn').addEventListener('click', () => {
            appState.showBefore = false;
            document.getElementById('afterBtn').classList.add('active');
            document.getElementById('beforeBtn').classList.remove('active');
            drawCanvas();
        });

        // Clear all
        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all lights?')) {
                appState.lightRuns = [];
                appState.miniLightAreas = [];
                appState.currentRun = [];
                appState.currentMiniTrace = [];
                appState.isDrawing = false;
                appState.isTracingMini = false;
                statusIndicator.style.display = 'none';
                updateLightRunsList();
                updateMiniAreasList();
                drawCanvas();
            }
        });

        // Export
        document.getElementById('exportBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'holiday-lights-mockup.png';
            link.href = canvas.toDataURL();
            link.click();
        });

        function updateLightRunsList() {
            const container = document.getElementById('runsContainer');
            const listElement = document.getElementById('lightRunsList');
            
            if (appState.lightRuns.length === 0) {
                listElement.style.display = 'none';
                return;
            }
            
            listElement.style.display = 'block';
            container.innerHTML = '';
            
            appState.lightRuns.forEach((run, index) => {
                const runElement = document.createElement('div');
                runElement.className = 'flex items-center justify-between bg-gray-800 p-2 rounded';
                runElement.innerHTML = `
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full" style="background-color: ${patternColors[run.pattern][0]}"></div>
                        <span class="text-sm text-gray-300">Run ${index + 1}</span>
                    </div>
                    <div class="flex items-center gap-1">
                        <button class="btn-secondary p-1" onclick="toggleRunVisibility('${run.id}')">
                            <i data-lucide="${run.visible ? 'eye' : 'eye-off'}"></i>
                        </button>
                        <button class="btn-danger p-1" onclick="deleteRun('${run.id}')">
                            <i data-lucide="trash-2"></i>
                        </button>
                    </div>
                `;
                container.appendChild(runElement);
            });
            
            lucide.createIcons();
        }

        function updateMiniAreasList() {
            const container = document.getElementById('areasContainer');
            const listElement = document.getElementById('miniAreasList');
            
            if (appState.miniLightAreas.length === 0) {
                listElement.style.display = 'none';
                return;
            }
            
            listElement.style.display = 'block';
            container.innerHTML = '';
            
            appState.miniLightAreas.forEach((area, index) => {
                const areaElement = document.createElement('div');
                areaElement.className = 'flex items-center justify-between bg-gray-800 p-2 rounded';
                areaElement.innerHTML = `
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full" style="background-color: ${patternColors[area.pattern][0]}"></div>
                        <span class="text-sm text-gray-300">Area ${index + 1}</span>
                    </div>
                    <div class="flex items-center gap-1">
                        <button class="btn-secondary p-1" onclick="toggleAreaVisibility('${area.id}')">
                            <i data-lucide="${area.visible ? 'eye' : 'eye-off'}"></i>
                        </button>
                        <button class="btn-danger p-1" onclick="deleteArea('${area.id}')">
                            <i data-lucide="trash-2"></i>
                        </button>
                    </div>
                `;
                container.appendChild(areaElement);
            });
            
            lucide.createIcons();
        }

        // Global functions for button handlers
        window.toggleRunVisibility = (id) => {
            const run = appState.lightRuns.find(r => r.id === id);
            if (run) {
                run.visible = !run.visible;
                updateLightRunsList();
                drawCanvas();
            }
        };

        window.deleteRun = (id) => {
            appState.lightRuns = appState.lightRuns.filter(r => r.id !== id);
            updateLightRunsList();
            drawCanvas();
        };

        window.toggleAreaVisibility = (id) => {
            const area = appState.miniLightAreas.find(a => a.id === id);
            if (area) {
                area.visible = !area.visible;
                updateMiniAreasList();
                drawCanvas();
            }
        };

        window.deleteArea = (id) => {
            appState.miniLightAreas = appState.miniLightAreas.filter(a => a.id !== id);
            updateMiniAreasList();
            drawCanvas();
        };

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (appState.isDrawing) {
                    appState.currentRun = [];
                    appState.isDrawing = false;
                    statusIndicator.style.display = 'none';
                    drawCanvas();
                }
                if (appState.isTracingMini) {
                    appState.currentMiniTrace = [];
                    appState.isTracingMini = false;
                    isMouseDown = false;
                    statusIndicator.style.display = 'none';
                    drawCanvas();
                }
            }
        });

        // Resize handler
        window.addEventListener('resize', () => {
            if (loadedImage) {
                resizeCanvas();
                drawCanvas();
            }
        });

        // Initialize
        resizeCanvas();
    </script>
</body>
</html>